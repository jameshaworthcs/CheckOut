<%# Only include script tags if not in JS route %>
<%- typeof isJsRoute === 'undefined' || !isJsRoute ? '<script>' : '' %>

// Dashboard data injected from server
const injectedDashboardData = <%- typeof dashboardData !== 'undefined' ? dashboardData : 'null' %>;

// Dashboard Module
const AutoCheckinDashboard = {
    // Cache keys
    CACHE_KEY: 'checkout_cache',
    DASHBOARD_CACHE_KEY: 'autocheckin_dashboard',

    // Week number mapping
    weekNumberMapping: [{"weekCommencing":"2024-09-16","weekEnding":"2024-09-22","weekNumber":"F"},{"weekCommencing":"2024-09-23","weekEnding":"2024-09-29","weekNumber":"1"},{"weekCommencing":"2024-09-30","weekEnding":"2024-10-06","weekNumber":"2"},{"weekCommencing":"2024-10-07","weekEnding":"2024-10-13","weekNumber":"3"},{"weekCommencing":"2024-10-14","weekEnding":"2024-10-20","weekNumber":"4"},{"weekCommencing":"2024-10-21","weekEnding":"2024-10-27","weekNumber":"5"},{"weekCommencing":"2024-10-28","weekEnding":"2024-11-03","weekNumber":"C"},{"weekCommencing":"2024-11-04","weekEnding":"2024-11-10","weekNumber":"6"},{"weekCommencing":"2024-11-11","weekEnding":"2024-11-17","weekNumber":"7"},{"weekCommencing":"2024-11-18","weekEnding":"2024-11-24","weekNumber":"8"},{"weekCommencing":"2024-11-25","weekEnding":"2024-12-01","weekNumber":"9"},{"weekCommencing":"2024-12-02","weekEnding":"2024-12-08","weekNumber":"10"},{"weekCommencing":"2024-12-09","weekEnding":"2024-12-15","weekNumber":"11"},{"weekCommencing":"2024-12-16","weekEnding":"2024-12-22","weekNumber":"V"},{"weekCommencing":"2024-12-23","weekEnding":"2024-12-29","weekNumber":"V"},{"weekCommencing":"2024-12-30","weekEnding":"2025-01-05","weekNumber":"V"},{"weekCommencing":"2025-01-06","weekEnding":"2025-01-12","weekNumber":"RV"},{"weekCommencing":"2025-01-13","weekEnding":"2025-01-19","weekNumber":"RA"},{"weekCommencing":"2025-01-20","weekEnding":"2025-01-26","weekNumber":"RA"},{"weekCommencing":"2025-01-27","weekEnding":"2025-02-02","weekNumber":"RA"},{"weekCommencing":"2025-02-03","weekEnding":"2025-02-09","weekNumber":"Rf"},{"weekCommencing":"2025-02-10","weekEnding":"2025-02-16","weekNumber":"1"},{"weekCommencing":"2025-02-17","weekEnding":"2025-02-23","weekNumber":"2"},{"weekCommencing":"2025-02-24","weekEnding":"2025-03-02","weekNumber":"3"},{"weekCommencing":"2025-03-03","weekEnding":"2025-03-09","weekNumber":"4"},{"weekCommencing":"2025-03-10","weekEnding":"2025-03-16","weekNumber":"5"},{"weekCommencing":"2025-03-17","weekEnding":"2025-03-23","weekNumber":"6"},{"weekCommencing":"2025-03-24","weekEnding":"2025-03-30","weekNumber":"7"},{"weekCommencing":"2025-03-31","weekEnding":"2025-04-06","weekNumber":"8"},{"weekCommencing":"2025-04-07","weekEnding":"2025-04-13","weekNumber":"V"},{"weekCommencing":"2025-04-14","weekEnding":"2025-04-20","weekNumber":"V"},{"weekCommencing":"2025-04-21","weekEnding":"2025-04-27","weekNumber":"9"},{"weekCommencing":"2025-04-28","weekEnding":"2025-05-04","weekNumber":"10"},{"weekCommencing":"2025-05-05","weekEnding":"2025-05-11","weekNumber":"11"},{"weekCommencing":"2025-05-12","weekEnding":"2025-05-18","weekNumber":"RV"},{"weekCommencing":"2025-05-19","weekEnding":"2025-05-25","weekNumber":"RA"},{"weekCommencing":"2025-05-26","weekEnding":"2025-06-01","weekNumber":"RA"},{"weekCommencing":"2025-06-02","weekEnding":"2025-06-08","weekNumber":"RA"}],

    // Required fields from API response
    requiredFields: ['checkinReportTime', 'checkinReport', 'username', 'autoLogData'],

    // Element IDs
    elements: {
        lastActiveDate: document.getElementById('last-active-date'),
        lastActiveTime: document.getElementById('last-active-time'),
        statusText: document.getElementById('status-text'),
        statusBadge: document.querySelector('.status-badge'),
        usernameDisplay: document.getElementById('username-display'),
        lastActive: document.querySelector('.last-active'),
        adminMessage: document.getElementById('admin-message'),
        adminEmail: document.getElementById('admin-email'),
        checkinToggleButton: document.getElementById('checkin-toggle-button'),
        helpButton: document.getElementById('help-button'),
        activityLogContainer: document.querySelector('.right-box-content'),
        timetableContainer: document.querySelector('.timetable-box-content')
    },

    // Status mappings
    statusMappings: {
        'Fail': { text: 'failed to refresh (see logs)', badge: 'ERROR', class: 'error' },
        'Disabled': { text: 'disabled', badge: 'DISABLED', class: 'disabled' },
        'Enabled': { text: 'pending', badge: 'PENDING', class: 'pending', suffix: ' (this can take up to an hour to change)' },
        'Normal': { text: 'successfully refreshed', badge: 'ACTIVE', class: 'active' },
        'Checkin': { text: 'successfully refreshed', badge: 'ACTIVE', class: 'active' }
    },

    // Initialize the dashboard
    init() {
        // If we have injected data, use it directly
        if (injectedDashboardData) {
            this.updateDashboard(injectedDashboardData);
        } else {
            this.checkAdminView();
            this.loadCachedData();
            this.fetchDashboardData();
        }
        this.setupEventListeners();
    },

    // Setup event listeners
    setupEventListeners() {
        if (this.elements.checkinToggleButton) {
            this.elements.checkinToggleButton.addEventListener('click', () => {
                const isEnabled = this.elements.checkinToggleButton.classList.contains('disable');
                if (isEnabled) {
                    this.showDisableConfirmModal();
                }
                // Enable functionality will be added later
            });
        }
        if (this.elements.helpButton) {
            this.elements.helpButton.addEventListener('click', () => {
                this.showHelpModal();
            });
        }
    },

    // Show disable confirmation modal
    showDisableConfirmModal() {
        const modalContent = `
            <h2>Disable AutoCheckin?</h2>
            <p>Are you sure you want to disable AutoCheckin? You will need to manually check in to your activities until you enable it again. Additionally, you will need to import your checkin account again to use AutoCheckin.</p>
            <div class="disable-confirm-buttons">
                <div class="button-row">
                    <a href="/support?pre=autocheckin" class="contact-support">Contact Support</a>
                    <button class="cancel-button">Cancel</button>
                </div>
                <span class="confirm-disable-text">Yes, disable AutoCheckin</span>
            </div>
        `;

        const { modal } = modalHelper.create({
            id: 'disable-confirm-modal',
            content: modalContent,
            customClass: 'disable-confirm-modal',
            showCloseButton: false
        });

        // Add event listeners to buttons
        const cancelButton = modal.querySelector('.cancel-button');
        const confirmText = modal.querySelector('.confirm-disable-text');

        cancelButton.addEventListener('click', () => {
            modalHelper.close('disable-confirm-modal');
        });

        confirmText.addEventListener('click', async () => {
            // Prevent multiple clicks
            if (confirmText.classList.contains('loading')) return;

            // Update UI to loading state
            confirmText.classList.add('loading');
            confirmText.textContent = 'Disabling AutoCheckin...';

            try {
                const response = await fetch('/auto/st', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ state: 0 })
                });

                if (response.ok) {
                    // Redirect to auto page with cache busting
                    window.location.href = `/auto?cachetid=${Date.now()}`;
                } else {
                    const data = await response.json();
                    displayNotice(
                        data.msg || 'Failed to disable AutoCheckin',
                        'error',
                        'AutoCheckin Error'
                    );
                    // Reset button state
                    confirmText.classList.remove('loading');
                    confirmText.textContent = 'Yes, disable AutoCheckin';
                }
            } catch (error) {
                displayNotice(
                    'Network error occurred while disabling AutoCheckin',
                    'error',
                    'Network Error'
                );
                // Reset button state
                confirmText.classList.remove('loading');
                confirmText.textContent = 'Yes, disable AutoCheckin';
            }
        });

        modalHelper.open('disable-confirm-modal');
    },

    // Show help modal
    showHelpModal() {
        const modalContent = `
            <h2>Help</h2>
            <p>Have a question or need advice? <a href="/support?pre=autocheckin">Feel free to reach out to us</a>.</p>
        `;

        const { modal } = modalHelper.create({
            id: 'help-modal',
            content: modalContent,
            customClass: 'help-modal',
            showCloseButton: true
        });

        // Add click handler for close button
        const closeButton = modal.querySelector('.close');
        if (closeButton) {
            closeButton.addEventListener('click', () => {
                modalHelper.close('help-modal');
            });
        }

        modalHelper.open('help-modal');
    },

    // Check if viewing as admin and show message if needed
    checkAdminView() {
        const urlParams = new URLSearchParams(window.location.search);
        const email = urlParams.get('email');
        
        if (email && this.elements.adminMessage && this.elements.adminEmail) {
            this.elements.adminEmail.textContent = email;
            this.elements.adminMessage.style.display = 'flex';
        }
    },

    // Load and display cached data if available
    loadCachedData() {
        // Skip loading cache if viewing as admin
        if (this.isAdminView()) return;

        const cachedData = this.getCachedData();
        if (cachedData) {
            this.updateDashboard(cachedData);
        }
    },

    // Get cached data from localStorage
    getCachedData() {
        // Skip getting cache if viewing as admin
        if (this.isAdminView()) return null;

        try {
            const cache = JSON.parse(localStorage.getItem(this.CACHE_KEY) || '{}');
            return cache[this.DASHBOARD_CACHE_KEY];
        } catch (error) {
            console.error('Error reading cache:', error);
            return null;
        }
    },

    // Update cache with new data
    updateCache(data) {
        // Skip updating cache if viewing as admin
        if (this.isAdminView()) return;

        try {
            const cache = JSON.parse(localStorage.getItem(this.CACHE_KEY) || '{}');
            cache[this.DASHBOARD_CACHE_KEY] = data;
            localStorage.setItem(this.CACHE_KEY, JSON.stringify(cache));
        } catch (error) {
            console.error('Error updating cache:', error);
        }
    },

    // Helper method to check if viewing as admin
    isAdminView() {
        const urlParams = new URLSearchParams(window.location.search);
        return !!urlParams.get('email');
    },

    // Fetch fresh data from API
    async fetchDashboardData() {
        try {
            const url = new URL('/api/autocheckin/dashboard/v1', window.location.origin);
            
            // Add email parameter if present in URL
            const urlParams = new URLSearchParams(window.location.search);
            const email = urlParams.get('email');
            if (email) {
                url.searchParams.append('email', email);
            }

            const response = await fetch(url);
            const data = await response.json();

            if (data.success) {
                this.validateAndUpdateDashboard(data.autoCheckinDashboardData);
            } else {
                displayNotice(
                    'Failed to fetch dashboard data: ' + (data.error || data.msg || data.message || 'Unknown error'),
                    'error',
                    'Dashboard data error'
                );
            }
        } catch (error) {
            displayNotice(
                'Failed to fetch dashboard data: ' + error.message,
                'error',
                'Dashboard data error'
            );
        }
    },

    // Validate data and collect any errors
    validateAndUpdateDashboard(data) {
        const errors = [];

        // Check if data exists and is an object
        if (!data || typeof data !== 'object') {
            displayNotice(
                'No dashboard data available',
                'error',
                'Dashboard data error'
            );
            return;
        }

        // Check for required fields
        const missingFields = this.requiredFields.filter(field => !data[field]);
        if (missingFields.length > 0) {
            errors.push(`Missing required fields: ${missingFields.join(', ')}`);
        }

        // Check if checkinReportTime is a valid date
        if (data.checkinReportTime && isNaN(new Date(data.checkinReportTime).getTime())) {
            errors.push('Invalid checkinReportTime format');
        }

        // We'll handle unknown statuses gracefully now, so no need to validate strictly
        if (data.checkinReport && typeof data.checkinReport !== 'string') {
            errors.push(`Invalid checkin report status format: ${data.checkinReport}`);
        }

        // If there are any errors, display them and return
        if (errors.length > 0) {
            displayNotice(
                'Dashboard data validation failed:\n' + errors.join('\n'),
                'error',
                'Dashboard data error'
            );
            return;
        }

        // If validation passes, update dashboard and cache
        this.updateDashboard(data);
        this.updateCache(data);
    },

    // Format date for display
    formatDate(dateString) {
        return new Date(dateString).toLocaleDateString('en-GB', {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        });
    },

    // Format time for display
    formatTime(dateString) {
        return new Date(dateString).toLocaleTimeString('en-GB', {
            hour: 'numeric',
            minute: 'numeric'
        });
    },

    // Format relative time for display
    formatRelativeTime(dateString) {
        const date = new Date(dateString);
        const now = new Date();
        const diffInSeconds = Math.floor((now - date) / 1000);
        
        const minute = 60;
        const hour = minute * 60;
        const day = hour * 24;
        const week = day * 7;
        const month = day * 30;
        const year = day * 365;

        if (diffInSeconds < minute) {
            return 'just now';
        } else if (diffInSeconds < hour) {
            const minutes = Math.floor(diffInSeconds / minute);
            return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
        } else if (diffInSeconds < day) {
            const hours = Math.floor(diffInSeconds / hour);
            return `${hours} hour${hours > 1 ? 's' : ''} ago`;
        } else if (diffInSeconds < week) {
            const days = Math.floor(diffInSeconds / day);
            return `${days} day${days > 1 ? 's' : ''} ago`;
        } else if (diffInSeconds < month) {
            const weeks = Math.floor(diffInSeconds / week);
            return `${weeks} week${weeks > 1 ? 's' : ''} ago`;
        } else if (diffInSeconds < year) {
            const months = Math.floor(diffInSeconds / month);
            return `${months} month${months > 1 ? 's' : ''} ago`;
        } else {
            const years = Math.floor(diffInSeconds / year);
            return `${years} year${years > 1 ? 's' : ''} ago`;
        }
    },

    // Format time for activity log
    formatActivityTime(timestamp) {
        const date = new Date(timestamp);
        const now = new Date();
        const diffInSeconds = Math.floor((now - date) / 1000);
        
        // If it's today, show relative time
        if (diffInSeconds < 24 * 60 * 60 && 
            date.getDate() === now.getDate() &&
            date.getMonth() === now.getMonth() &&
            date.getFullYear() === now.getFullYear()) {
            return this.formatRelativeTime(timestamp);
        }

        // Otherwise show formatted date
        return date.toLocaleString('en-US', {
            month: 'short',
            day: 'numeric',
            year: 'numeric',
            hour: 'numeric',
            minute: 'numeric',
            hour12: true
        });
    },

    // Get state class for activity log item
    getStateClass(state) {
        state = state.toLowerCase();
        if (state === 'checkin') {
            return 'state-checkin';
        } else if (state === 'enabled' || state === 'normal') {
            return '';
        } else if (state === 'fail') {
            return 'state-fail';
        }
        return 'state-other';
    },

    // Get status information based on checkin report
    getStatusInfo(checkinReport) {
        // If the status is unknown, treat it as a Fail
        const status = this.statusMappings[checkinReport] || this.statusMappings['Fail'];
        return {
            text: `<span class="${status.class}-text">${status.text}</span>${status.suffix || ''}`,
            badge: status.badge,
            class: status.class
        };
    },

    // Update activity log
    updateActivityLog(logData) {
        if (!this.elements.activityLogContainer || !Array.isArray(logData)) return;

        // Clear skeleton loading state
        this.elements.activityLogContainer.innerHTML = '';

        // Create activity log container
        const logContainer = document.createElement('div');
        logContainer.className = 'activity-log-container';

        // Add log items
        logData.forEach(log => {
            const logItem = document.createElement('div');
            logItem.className = `activity-log-item ${this.getStateClass(log.state)}`;

            const message = document.createElement('div');
            message.className = 'activity-log-message';
            message.textContent = log.message;

            const time = document.createElement('div');
            time.className = 'activity-log-time';
            time.textContent = this.formatActivityTime(log.timestamp);

            logItem.appendChild(message);
            logItem.appendChild(time);
            logContainer.appendChild(logItem);
        });

        this.elements.activityLogContainer.appendChild(logContainer);
    },

    // Format date for timetable display
    formatTimetableDate(dateString) {
        const date = new Date(dateString);
        return date.toLocaleDateString('en-GB', {
            weekday: 'long',
            day: 'numeric',
            month: 'long'
        });
    },

    // Get status class based on attendance state
    getAttendanceStatusClass(state) {
        state = state.toLowerCase();
        if (state === 'present') {
            return 'status-present';
        } else if (state === 'absent') {
            return 'status-absent';
        }
        return 'status-unknown';
    },

    // Get status emoji and text based on attendance state
    getAttendanceStatusText(state) {
        state = state.toLowerCase();
        if (state === 'present') {
            return '✅ present';
        } else if (state === 'absent') {
            return '❌ absent';
        }
        return '❔ unknown';
    },

    // Update timetable with attendance data
    updateTimetable(data) {
        if (!this.elements.timetableContainer) return;

        // Clear existing content
        this.elements.timetableContainer.innerHTML = '';

        // Handle sync data that could be either a string or an object
        let syncData;
        try {
            syncData = typeof data.sync === 'string' ? JSON.parse(data.sync) : data.sync;
        } catch (error) {
            console.error('Error parsing sync data:', error);
            syncData = null;
        }

        // Get current year and week
        const now = new Date();
        const currentYear = now.getFullYear();
        const currentWeek = this.getWeekNumber(now);
        
        // If no sync data, show "Data available soon" message
        if (!syncData?.attendanceData) {
            this.showTimetableDataAvailableSoon();
            return;
        }
        
        // Collect all available weeks from the API response
        const availableWeeks = [];
        
        // Loop through years and weeks to find all available weeks
        Object.keys(syncData.attendanceData).forEach(year => {
            Object.keys(syncData.attendanceData[year]).forEach(week => {
                if (syncData.attendanceData[year][week] && syncData.attendanceData[year][week].length > 0) {
                    // Calculate the date for the start of this week
                    const weekStartDate = this.getDateOfISOWeek(parseInt(week), parseInt(year));
                    
                    availableWeeks.push({
                        year: parseInt(year),
                        week: parseInt(week),
                        weekStartDate,
                        formattedDate: this.formatWeekStartDate(weekStartDate)
                    });
                }
            });
        });
        
        // Sort weeks chronologically (oldest to newest)
        availableWeeks.sort((a, b) => {
            if (a.year !== b.year) return a.year - b.year;
            return a.week - b.week;
        });
        
        // If no available weeks, show "Data available soon" message
        if (availableWeeks.length === 0) {
            this.showTimetableDataAvailableSoon();
            return;
        }
        
        // Find the index of the current week in the available weeks
        let currentWeekIndex = availableWeeks.findIndex(w => 
            w.year === currentYear && w.week === currentWeek
        );
        
        // If current week not found, default to the most recent week
        if (currentWeekIndex === -1) {
            currentWeekIndex = availableWeeks.length - 1;
        }
        
        // Create pagination container if we have multiple weeks
        if (availableWeeks.length > 1) {
            const paginationContainer = document.createElement('div');
            paginationContainer.className = 'timetable-pagination';
            
            // Create pagination navigation container
            const paginationNav = document.createElement('div');
            paginationNav.className = 'pagination-nav';
            
            // Add previous week button
            const prevButton = document.createElement('button');
            prevButton.className = 'pagination-button prev-button';
            prevButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512" fill="currentColor" width="1rem" height="1rem"><path d="M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l192 192c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256 246.6 86.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-192 192z"/></svg>';
            prevButton.disabled = currentWeekIndex === 0;
            prevButton.title = "Previous week";
            
            // Add week display (shows the date range)
            const weekDisplay = document.createElement('div');
            weekDisplay.className = 'week-display';
            weekDisplay.innerHTML = this.formatWeekRange(availableWeeks[currentWeekIndex].weekStartDate);
            
            // Add next week button
            const nextButton = document.createElement('button');
            nextButton.className = 'pagination-button next-button';
            nextButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512" fill="currentColor" width="1rem" height="1rem"><path d="M310.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-192 192c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L242.7 256 73.4 86.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l192 192z"/></svg>';
            nextButton.disabled = currentWeekIndex === availableWeeks.length - 1;
            nextButton.title = "Next week";
            
            // Add event listeners for navigation buttons
            prevButton.addEventListener('click', () => {
                if (currentWeekIndex > 0) {
                    currentWeekIndex--;
                    const weekData = availableWeeks[currentWeekIndex];
                    this.displayWeekTimetable(syncData, weekData.year, weekData.week);
                    weekDisplay.innerHTML = this.formatWeekRange(weekData.weekStartDate);
                    
                    // Update button states
                    prevButton.disabled = currentWeekIndex === 0;
                    nextButton.disabled = false;
                }
            });
            
            nextButton.addEventListener('click', () => {
                if (currentWeekIndex < availableWeeks.length - 1) {
                    currentWeekIndex++;
                    const weekData = availableWeeks[currentWeekIndex];
                    this.displayWeekTimetable(syncData, weekData.year, weekData.week);
                    weekDisplay.innerHTML = this.formatWeekRange(weekData.weekStartDate);
                    
                    // Update button states
                    nextButton.disabled = currentWeekIndex === availableWeeks.length - 1;
                    prevButton.disabled = false;
                }
            });
            
            // Assemble pagination navigation
            paginationNav.appendChild(prevButton);
            paginationNav.appendChild(weekDisplay);
            paginationNav.appendChild(nextButton);
            
            // Assemble pagination container
            paginationContainer.appendChild(paginationNav);
            
            this.elements.timetableContainer.appendChild(paginationContainer);
        }
        
        // Display the timetable for the current week
        this.displayWeekTimetable(syncData, availableWeeks[currentWeekIndex].year, availableWeeks[currentWeekIndex].week);
    },
    
    // Helper function to show "Data available soon" message
    showTimetableDataAvailableSoon() {
        this.elements.timetableContainer.innerHTML = `
            <div class="coming-soon-container">
                <div class="coming-soon-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor" width="2rem" height="2rem">
                        <path d="M464 256A208 208 0 1 1 48 256a208 208 0 1 1 416 0zM0 256a256 256 0 1 0 512 0A256 256 0 1 0 0 256zM232 120l0 136c0 8 4 15.5 10.7 20l96 64c11 7.4 25.9 4.4 33.3-6.7s4.4-25.9-6.7-33.3L280 243.2 280 120c0-13.3-10.7-24-24-24s-24 10.7-24 24z"/>
                    </svg>
                </div>
                <div>Data available soon.</div>
                <div style="font-size: 0.8rem;">It usually takes up to 24 hours for attendance data to be available.</div><br>
            </div>
        `;
    },
    
    // Helper function to format week start date
    formatWeekStartDate(date) {
        return date.toLocaleDateString('en-GB', {
            day: 'numeric',
            month: 'short',
            year: 'numeric'
        });
    },
    
    // Helper function to format week range (e.g., "1-7 March")
    formatWeekRange(startDate) {
        const endDate = new Date(startDate);
        endDate.setDate(startDate.getDate() + 6); // End of week (6 days after start)
        
        const startDay = startDate.getDate();
        const endDay = endDate.getDate();
        
        // Get month names - use short month format for better space efficiency
        const month = endDate.toLocaleDateString('en-GB', { month: 'short' });
        const year = endDate.getFullYear();

        // Get week number from mapping
        const weekNumber = this.getWeekNumber(startDate);
        
        // Format the date range
        let dateRange;
        if (startDate.getMonth() === endDate.getMonth()) {
            dateRange = `${startDay}-${endDay} ${month} ${year}`;
        } else {
            // If they span different months
            const startMonth = startDate.toLocaleDateString('en-GB', { month: 'short' });
            dateRange = `${startDay} ${startMonth} - ${endDay} ${month} ${year}`;
        }
        
        // Return with week number if available, otherwise just the date range
        if (weekNumber) {
            return `<strong>Week ${weekNumber}</strong><br><span style="font-weight: normal; color: #666; font-size: 14px;">${dateRange}</span>`;
        } else {
            return dateRange;
        }
    },

    // Helper function to get the week number from the week commencing date
    getWeekNumber(date) {
        const formattedDate = date.toISOString().split('T')[0];
        const matchingWeek = this.weekNumberMapping.find(week => 
            week.weekCommencing === formattedDate
        );
        return matchingWeek ? matchingWeek.weekNumber : null;
    },

    // Helper function to get the date of the Monday in a given ISO week
    getDateOfISOWeek(week, year) {
        const simple = new Date(year, 0, 1 + (week - 1) * 7);
        const dayOfWeek = simple.getDay();
        const ISOweekStart = simple;
        if (dayOfWeek <= 4) {
            ISOweekStart.setDate(simple.getDate() - simple.getDay() + 1);
        } else {
            ISOweekStart.setDate(simple.getDate() + 8 - simple.getDay());
        }
        return ISOweekStart;
    },
    
    // Display timetable for a specific week
    displayWeekTimetable(syncData, year, week) {
        // Get attendance data for the specified year and week
        const attendanceData = syncData?.attendanceData?.[year]?.[week];
        
        // Clear existing timetable content (except pagination)
        const paginationElement = this.elements.timetableContainer.querySelector('.timetable-pagination');
        if (paginationElement) {
            this.elements.timetableContainer.innerHTML = '';
            this.elements.timetableContainer.appendChild(paginationElement);
        } else {
            // If no pagination element exists, just clear everything
            this.elements.timetableContainer.innerHTML = '';
        }
        
        if (!attendanceData || attendanceData.length === 0) {
            const noDataMessage = document.createElement('div');
            noDataMessage.className = 'coming-soon-container';
            noDataMessage.innerHTML = `
                <div>No timetable data available for this week.</div>
            `;
            this.elements.timetableContainer.appendChild(noDataMessage);
            return;
        }
        
        // Group activities by date
        const groupedActivities = {};
        attendanceData.forEach(activity => {
            if (!groupedActivities[activity.date]) {
                groupedActivities[activity.date] = [];
            }
            groupedActivities[activity.date].push(activity);
        });

        // Sort dates
        const sortedDates = Object.keys(groupedActivities).sort();

        // Create timetable sections for each date
        sortedDates.forEach(date => {
            const activities = groupedActivities[date];
            const daySection = document.createElement('div');
            daySection.className = 'timetable-day-section';

            // Add day divider
            daySection.innerHTML = `
                <div class="timetable-day-divider">
                    <div class="timetable-day-name">${this.formatTimetableDate(date)}</div>
                </div>
            `;

            // Sort activities by start time
            activities.sort((a, b) => a.startTime.localeCompare(b.startTime));

            // Add activities
            activities.forEach(activity => {
                const activityItem = document.createElement('div');
                activityItem.className = 'box-content-item timetable-item';
                activityItem.innerHTML = `
                    <div class="timetable-item-activity-reference">${activity.activityReference}</div>
                    <div class="timetable-item-time">${activity.startTime}-${activity.finishTime}</div>
                    <div class="timetable-item-dropdown">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                            <path d="M7.247 11.14 2.451 5.658C1.885 5.013 2.345 4 3.204 4h9.592a1 1 0 0 1 .753 1.659l-4.796 5.48a1 1 0 0 1-1.506 0z"/>
                        </svg>
                    </div>
                    <div class="timetable-item-details">
                        <div class="timetable-item-lecturer">${activity.lecturerName}</div>
                        <div class="timetable-item-location">${activity.location}</div>
                    </div>
                    <div class="timetable-item-status ${this.getAttendanceStatusClass(activity.attendanceState)}">
                        ${this.getAttendanceStatusText(activity.attendanceState)}
                    </div>
                `;

                // Add click handler for dropdown
                const dropdown = activityItem.querySelector('.timetable-item-dropdown');
                const details = activityItem.querySelector('.timetable-item-details');
                
                dropdown.addEventListener('click', () => {
                    dropdown.classList.toggle('expanded');
                    details.classList.toggle('expanded');
                });

                daySection.appendChild(activityItem);
            });

            this.elements.timetableContainer.appendChild(daySection);
        });
    },

    // Update dashboard with new data
    updateDashboard(data) {
        if (!data) return;

        const { checkinReportTime, checkinReport, username, checkinstate, autoLogData } = data;
        const statusInfo = this.getStatusInfo(checkinReport);

        try {
            // Update username display
            if (this.elements.usernameDisplay && username) {
                this.elements.usernameDisplay.textContent = username;
            }

            // Update last active time
            if (this.elements.lastActive && checkinReportTime) {
                this.elements.lastActive.textContent = this.formatRelativeTime(checkinReportTime);
            }

            // Update status elements
            if (this.elements.lastActiveDate) {
                this.elements.lastActiveDate.textContent = this.formatDate(checkinReportTime);
            }
            if (this.elements.lastActiveTime) {
                this.elements.lastActiveTime.textContent = this.formatTime(checkinReportTime);
            }
            if (this.elements.statusText) {
                this.elements.statusText.innerHTML = statusInfo.text;
            }
            if (this.elements.statusBadge) {
                this.elements.statusBadge.textContent = statusInfo.badge;
                this.elements.statusBadge.className = `status-badge ${statusInfo.class}`;
            }

            // Update checkin toggle button
            if (this.elements.checkinToggleButton) {
                const urlParams = new URLSearchParams(window.location.search);
                const email = urlParams.get('email');

                if (email) {
                    this.elements.checkinToggleButton.textContent = 'Unable to Enable/Disable from here';
                    this.elements.checkinToggleButton.className = 'disabled';
                } else {
                    const isEnabled = checkinstate === 1;
                    this.elements.checkinToggleButton.textContent = isEnabled ? 'Disable AutoCheckin' : 'Enable AutoCheckin';
                    this.elements.checkinToggleButton.className = isEnabled ? 'disable' : 'enable';
                }
            }

            // Update activity log
            this.updateActivityLog(autoLogData);

            // Update timetable
            this.updateTimetable(data);
        } catch (error) {
            displayNotice(
                'Failed to update dashboard display: ' + error.message,
                'error',
                'Dashboard update error',
                0
            );
        }
    }
};

// Initialize dashboard when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    AutoCheckinDashboard.init();
});
<%- typeof isJsRoute === 'undefined' || !isJsRoute ? '</script>' : '' %>